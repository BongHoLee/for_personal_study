# Phase 1 피드백: 기초 이론 및 프로젝트 구조 설정

## 잘 수행한 부분 ✅

### 1. 도메인 모델링 접근
- **구체적인 비즈니스 규칙 정의**: 계좌 상태('정지', '정상'), 거래 타입('송금', '인출') 등을 명확히 정의
- **실무적 관점 적용**: "정지 상태 계좌는 송금 대상이 될 수 없다"는 실제 은행 시스템의 비즈니스 규칙을 잘 반영
- **자기참조 방지**: "자기 자신 계좌로 송금 불가" 규칙으로 엣지 케이스 고려

### 2. Money 값 객체 구현
- **BigDecimal 사용**: 금융 도메인에서 정밀도가 중요한 금액 처리에 적절한 타입 선택
- **Inline Value Class**: Kotlin의 성능 최적화 기능을 활용하여 런타임 오버헤드 제거
- **연산자 오버로딩**: `plus`, `minus` 연산자로 도메인 친화적 API 제공

## 개선해야 할 부분 🔧

### 1. Money 클래스의 불변식 검증 부족
**현재 문제**:
```kotlin
// 음수 금액 생성이 가능
val negativeAmount = Money.of(-100)
```

**구체적 개선 방안**:
- `init` 블록에서 음수 검증 추가
- 연산 결과가 음수가 되는 경우의 처리 정책 결정 (예외 vs 0원 반환)
- 예시: `require(amount >= BigDecimal.ZERO) { "Money amount cannot be negative: $amount" }`

### 2. 거래 내역(Activity) 모델링의 모호함
**현재 문제**:
- "거래 내역에 거래 타입, 거래 시간, 잔고 표기"라고 했지만 구체적 설계 없음
- 송금 시 출금자와 입금자 모두의 거래 내역을 어떻게 관리할지 불분명

**구체적 개선 방안**:
1. 거래 타입을 enum으로 정의: `DEPOSIT`, `WITHDRAWAL`
2. 송금의 경우 두 개의 Activity 생성 방식 vs 하나의 Transfer 엔티티 방식 결정
3. 잔고 계산 시점 결정: 실시간 계산 vs 거래 시점 저장

### 3. 도메인 경계의 불명확성
**현재 문제**:
- Account와 Activity 간의 관계가 애매함
- 어떤 것이 애그리게이트 루트인지 불분명

**구체적 개선 방안**:
1. **애그리게이트 식별**: Account를 루트로 하고, Activity를 그 하위로 둘 것인지 결정
2. **트랜잭션 경계**: 송금 시 두 계좌를 어떻게 일관성 있게 업데이트할지 고려
3. **도메인 서비스 필요성**: 계좌 간 송금 로직을 별도 서비스로 분리할지 검토

## 다음 Phase 2를 위한 준비사항 📋

### 1. 우선 고민해볼 질문들
- AccountId는 Long이 적절한가? UUID vs Long vs String의 장단점은?
- Activity의 생명주기는 누가 관리할 것인가?
- 송금 한도 검증은 어디서 수행할 것인가? (Entity vs Domain Service)

### 2. 실습 시 주의사항
- 각 엔티티의 `equals`/`hashCode` 구현 전략 결정
- 불변 객체 설계 원칙 준수
- 테스트 작성 시 경계 조건(boundary conditions) 포함

### 3. 추천 학습 순서
1. AccountId, ActivityId 값 객체부터 시작 (간단한 것부터)
2. Activity 엔티티 (비즈니스 규칙이 상대적으로 단순)
3. Account 엔티티 (복잡한 비즈니스 로직 포함)
4. ActivityWindow (컬렉션 관리 복잡성)

## 학습자의 고민 포인트에 대한 답변 💭

### 1. "머릿속 도메인 모델링을 구체화하는 전략"
**훌륭한 질문입니다!** 이는 모든 도메인 모델러가 겪는 핵심 과제입니다.

**구체화 전략**:
1. **이벤트 스토밍 접근**: "송금이 일어날 때 무엇이 발생하는가?"
   - 사용자가 송금 요청 → 출금 계좌 잔액 확인 → 송금 한도 확인 → 거래 생성 → 잔액 업데이트
2. **예외 시나리오 탐색**: "무엇이 잘못될 수 있는가?"
   - 잔액 부족, 계좌 정지, 일일 한도 초과, 네트워크 오류 등
3. **실제 사례 기반 검증**: "실제 은행에서는 어떻게 처리하는가?"
   - KB국민은행, 신한은행 앱 사용해보며 UX 분석

**다음 Phase에서 실천할 방법**:
- 각 엔티티 설계 시 "이 객체가 어떤 상황에서 생성/변경/소멸되는가?" 질문
- 불가능한 상태 조합을 먼저 나열하고, 이를 방지하는 불변식 설계

### 2. "Money의 도메인 특화 규칙"
**매우 중요한 통찰!** 일반적인 Money와 계좌 도메인의 Money는 달라야 합니다.

**계좌 맥락에서의 Money 특화 규칙**:
```kotlin
// 예시: 계좌 도메인 특화 Money
value class AccountMoney(val amount: BigDecimal) {
    init {
        // 은행 시스템에서는 보통 원 단위까지만
        require(amount.scale() <= 0) { "Account money must be in whole currency units" }
        // 송금 최소 금액 (예: 1원 이상)
        require(amount >= BigDecimal.ONE) { "Transfer amount must be at least 1 won" }
    }
    
    // 송금 수수료 계산
    fun calculateTransferFee(): AccountMoney = ...
    
    // 일일 한도와 비교
    fun isWithinDailyLimit(limit: AccountMoney): Boolean = ...
}
```

**음수 처리 전략 결정 필요**:
- **Option 1**: 음수 금지 + 별도 부채(Debt) 객체 사용
- **Option 2**: 음수 허용 + 마이너스 통장 개념
- **추천**: Option 1 (명확한 의미 전달)

## 추가 피드백: 성장하는 사고 과정 🌱

### 뛰어난 점
- **메타인지적 사고**: 자신의 학습 과정을 객관화하여 바라봄
- **실무적 의문**: "일반적인 것 vs 도메인 특화"의 차이점 인식
- **구체적 질문**: 추상적인 고민이 아닌 구현 가능한 수준의 질문 제기

### 다음 단계에서 더 발전시킬 점
1. **가설-검증 사이클**: 설계 결정을 내린 후, 간단한 테스트로 검증
2. **트레이드오프 사고**: "A를 선택하면 B를 포기한다"는 관점 도입
3. **진화 가능한 설계**: "나중에 요구사항이 바뀌면 어떻게 대응할 것인가?" 고려

## 전체적 평가 📊

**현재 수준**: 단순 구현을 넘어서서 **도메인 전문가의 사고 과정**을 보이기 시작함

**성장 포인트**: 이론과 실무 사이의 간격을 메우려는 의지와 구체적인 질문 능력이 돋보임. Phase 2에서 이러한 고민들을 코드로 구현해내는 능력 개발이 핵심