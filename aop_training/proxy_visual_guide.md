# 🎨 프록시 패턴 시각적 가이드

> 프록시 패턴의 동작 원리를 다이어그램과 함께 이해해보세요

## 📋 목차
1. [프록시 패턴 기본 개념](#-프록시-패턴-기본-개념)
2. [정적 프록시 다이어그램](#-정적-프록시-다이어그램)
3. [JDK 동적 프록시 다이어그램](#-jdk-동적-프록시-다이어그램)
4. [CGLIB 프록시 다이어그램](#-cglib-프록시-다이어그램)
5. [프록시 방식 비교표](#-프록시-방식-비교표)
6. [실행 흐름 다이어그램](#-실행-흐름-다이어그램)

---

## 🔍 프록시 패턴 기본 개념

### 프록시 패턴이란?

```mermaid
graph LR
    A[Client] --> B[Proxy]
    B --> C[RealSubject]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
```

프록시는 **실제 객체에 대한 접근을 제어하는 대리인 역할**을 합니다.

### 프록시가 해결하는 문제들

```mermaid
graph TD
    A[횡단 관심사<br/>Cross-cutting Concerns] --> B[로깅]
    A --> C[보안/인증]
    A --> D[트랜잭션]
    A --> E[캐싱]
    A --> F[성능 모니터링]
    A --> G[예외 처리]
```

---

## 🔧 정적 프록시 다이어그램

### 클래스 구조

```mermaid
classDiagram
    class UserService {
        <<interface>>
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class UserServiceImpl {
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class UserLogProxy {
        -userService: UserService
        -logInvocator: LogInvocator
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class LogInvocator {
        -callCount: AtomicInteger
        +executeWithLog(Function) T
        +getCallCount() int
        +resetCallCount()
    }
    
    UserService <|.. UserServiceImpl
    UserService <|.. UserLogProxy
    UserLogProxy --> UserService
    UserLogProxy --> LogInvocator
```

### 실행 흐름

```mermaid
sequenceDiagram
    participant C as Client
    participant P as UserLogProxy
    participant L as LogInvocator
    participant T as UserServiceImpl
    
    C->>P: findUser(1L)
    P->>L: executeWithLog(() -> ...)
    L->>L: 로그 시작 + 시간 측정
    L->>T: findUser(1L)
    T-->>L: return "User-1"
    L->>L: 로그 종료 + 시간 측정
    L-->>P: return "User-1"
    P-->>C: return "User-1"
```

### 정적 프록시의 특징
```
✅ 장점:
- 구조가 단순하고 명확함
- 컴파일 시점에 모든 구조가 결정됨
- 디버깅이 쉬움

❌ 단점:
- 각 클래스마다 프록시 클래스를 직접 작성해야 함
- 코드 중복이 많이 발생
- 횡단 관심사가 여러 클래스에 흩어짐
```

---

## 💫 JDK 동적 프록시 다이어그램

### 런타임 구조

```mermaid
classDiagram
    class UserService {
        <<interface>>
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class UserServiceImpl {
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class ProxyInstance {
        <<runtime generated>>
        Generated by Proxy.newProxyInstance()
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class LoggingInvocationHandler {
        -target: Any
        +invoke(proxy, method, args) Any?
    }
    
    UserService <|.. UserServiceImpl
    UserService <|.. ProxyInstance
    ProxyInstance --> LoggingInvocationHandler
    LoggingInvocationHandler --> UserServiceImpl
```

### JDK 동적 프록시 생성 과정

```mermaid
flowchart TD
    A[클라이언트 요청] --> B[Proxy.newProxyInstance 호출]
    B --> C["ClassLoader 획득<br/>인터페이스 배열 획득<br/>InvocationHandler 생성"]
    C --> D[JVM이 런타임에 프록시 클래스 생성]
    D --> E["$Proxy0 클래스<br/>(바이트코드로 생성)"]
    E --> F[프록시 인스턴스 반환]
    
    subgraph "생성된 프록시 클래스 구조"
        G["class $Proxy0 implements UserService {<br/>  private InvocationHandler h;<br/>  public String findUser(Long id) {<br/>    return (String) h.invoke(this, method, args);<br/>  }<br/>}"]
    end
    
    D --> G
    
    style A fill:#e1f5fe
    style F fill:#e8f5e8
    style G fill:#fff3e0
```

### InvocationHandler 실행 흐름

```mermaid
sequenceDiagram
    participant C as Client
    participant P as $Proxy0
    participant IH as LoggingInvocationHandler
    participant T as UserServiceImpl
    
    C->>P: findUser(1L)
    P->>IH: invoke(proxy, method, args)
    
    Note over IH: 전처리 시작
    IH->>IH: startTime = currentTimeMillis()
    IH->>IH: log.info("Method start: {}", method.name)
    
    Note over IH,T: 실제 메서드 호출
    IH->>T: method.invoke(target, args)
    T-->>IH: return "User-1"
    
    Note over IH: 후처리
    IH->>IH: endTime = currentTimeMillis()
    IH->>IH: log.info("Execution time: {}ms", endTime - startTime)
    
    IH-->>P: return "User-1"
    P-->>C: return "User-1"
```

### JDK 동적 프록시 특징
```
✅ 장점:
- JDK 표준 라이브러리 (별도 의존성 불필요)
- 런타임에 프록시 생성 (유연성)
- 하나의 InvocationHandler로 여러 인터페이스 처리 가능

❌ 단점:
- 인터페이스가 반드시 필요
- 리플렉션 사용으로 인한 성능 오버헤드
- 인터페이스 기반이므로 클래스 직접 프록시 불가능
```

---

## 🚀 CGLIB 프록시 다이어그램

### 상속 기반 구조

```mermaid
classDiagram
    class OrderService {
        <<원본 클래스>>
        +createOrder(Long, int) String
        +cancelOrder(String) Boolean
    }
    
    class OrderServiceEnhancerByCGLIB {
        <<CGLIB 생성 프록시>>
        -methodInterceptor: MethodInterceptor
        +createOrder(Long, int) String
        +cancelOrder(String) Boolean
    }
    
    class LoggingMethodInterceptor {
        -target: Any
        +intercept(obj, method, args, proxy) Any?
    }
    
    OrderService <|-- OrderServiceEnhancerByCGLIB
    OrderServiceEnhancerByCGLIB --> LoggingMethodInterceptor
    LoggingMethodInterceptor --> OrderService
```

### CGLIB 프록시 생성 과정

```mermaid
flowchart TD
    A[클라이언트 요청] --> B[Enhancer 인스턴스 생성]
    B --> C["setSuperclass()<br/>대상 클래스 지정"]
    C --> D["setCallback()<br/>MethodInterceptor 설정"]
    D --> E[바이트코드 조작으로 서브클래스 생성]
    E --> F["OrderService$$EnhancerByCGLIB<br/>클래스 생성"]
    F --> G[프록시 인스턴스 반환]
    
    subgraph "생성된 CGLIB 프록시 구조"
        H["class OrderService$$EnhancerByCGLIB<br/>    extends OrderService {<br/>  private MethodInterceptor callback;<br/>  <br/>  public String createOrder(Long id, int qty) {<br/>    return callback.intercept(this, method, args, proxy);<br/>  }<br/>}"]
    end
    
    E --> H
    
    style A fill:#e1f5fe
    style G fill:#e8f5e8
    style H fill:#fff3e0
```

### MethodInterceptor 실행 흐름

```mermaid
sequenceDiagram
    participant C as Client
    participant P as CGLIB Proxy
    participant MI as LoggingMethodInterceptor
    participant S as OrderService(Super)
    
    C->>P: createOrder(1L, 2)
    P->>MI: intercept(obj, method, args, proxy)
    
    Note over MI: 전처리 시작
    MI->>MI: log.info("Method call: {}", method.name)
    MI->>MI: startTime = currentTimeMillis()
    
    Note over MI,S: 상위 클래스 메서드 호출
    MI->>S: proxy.invokeSuper(obj, args)
    S-->>MI: return "Order created: product=1, qty=2"
    
    Note over MI: 후처리
    MI->>MI: endTime = currentTimeMillis()
    MI->>MI: log.info("Execution time: {}ms", endTime - startTime)
    
    MI-->>P: return result
    P-->>C: return result
```

### CGLIB 프록시 특징
```
✅ 장점:
- 인터페이스 없이도 프록시 생성 가능
- 클래스 기반 프록시 (더 유연함)
- Spring에서 기본적으로 사용

❌ 단점:
- 별도 라이브러리 의존성 필요
- final 클래스/메서드는 프록시 불가능
- 바이트코드 조작으로 인한 복잡성
- 기본 생성자가 필요함
```

---

## 📊 프록시 방식 비교표

| 특성 | 정적 프록시 | JDK 동적 프록시 | CGLIB 프록시 |
|------|-------------|----------------|-------------|
| **생성 시점** | 컴파일 시점 | 런타임 | 런타임 |
| **인터페이스 필요** | ✅ | ✅ | ❌ |
| **별도 의존성** | ❌ | ❌ | ✅ |
| **성능** | 가장 빠름 | 중간 | 느림 |
| **메모리 사용량** | 적음 | 중간 | 많음 |
| **final 클래스** | 가능 | 불가능 | 불가능 |
| **final 메서드** | 가능 | 가능 | 불가능 |
| **디버깅 난이도** | 쉬움 | 보통 | 어려움 |
| **코드 유지보수** | 어려움 | 쉬움 | 쉬움 |

---

## 🔄 실행 흐름 다이어그램

### JDK vs CGLIB 실행 흐름 비교

```mermaid
sequenceDiagram
    participant C as Client
    participant P1 as JDK Proxy
    participant IH as InvocationHandler
    participant T1 as Target(Interface)
    
    participant P2 as CGLIB Proxy
    participant MI as MethodInterceptor
    participant T2 as Target(Class)

    Note over C,T2: JDK 동적 프록시 흐름
    C->>P1: method()
    P1->>IH: invoke(proxy, method, args)
    IH->>IH: 전처리 (로깅, 시간 측정)
    IH->>T1: method.invoke(target, args)
    T1-->>IH: return result
    IH->>IH: 후처리 (로깅, 시간 측정)
    IH-->>P1: return result
    P1-->>C: return result

    Note over C,T2: CGLIB 프록시 흐름
    C->>P2: method()
    P2->>MI: intercept(obj, method, args, proxy)
    MI->>MI: 전처리 (로깅, 시간 측정)
    MI->>T2: proxy.invokeSuper(obj, args)
    T2-->>MI: return result
    MI->>MI: 후처리 (로깅, 시간 측정)
    MI-->>P2: return result
    P2-->>C: return result
```

---

## 🎯 Spring에서의 프록시 선택 전략

### Spring AOP 프록시 선택 흐름도

```mermaid
flowchart TD
    A[Target Bean 분석] --> B{인터페이스 구현?}
    
    B -->|Yes| C[JDK 동적 프록시]
    B -->|No| D[CGLIB 프록시]
    
    B -->|proxy-target-class=true| D
    
    C --> E["✅ JDK 표준 방식<br/>✅ 성능 우수<br/>✅ 메모리 효율<br/>❌ 인터페이스 필수"]
    
    D --> F["✅ Spring 기본 방식<br/>✅ 인터페이스 불필요<br/>✅ 유연성 높음<br/>❌ final 제약사항"]
    
    subgraph "설정으로 강제 선택 가능"
        G["@EnableAspectJAutoProxy<br/>(proxyTargetClass = true)"]
        H["spring.aop.proxy-target-class=true"]
    end
    
    G -.-> D
    H -.-> D
    
    style A fill:#e1f5fe
    style C fill:#e8f5e8
    style D fill:#fff3e0
    style E fill:#f0f8ff
    style F fill:#f5f5dc
```

### 설정을 통한 프록시 강제 선택
```kotlin
// application.yml
spring:
  aop:
    proxy-target-class: true  # CGLIB 강제 사용

// 또는 어노테이션
@EnableAspectJAutoProxy(proxyTargetClass = true)
```

---

## 🧪 실습에서 확인할 수 있는 것들

### 1. 프록시 객체 타입 확인
```kotlin
val proxy = createProxy(userService)
println("Proxy class: ${proxy.javaClass.name}")
println("Is JDK Proxy: ${Proxy.isProxyClass(proxy.javaClass)}")
println("Is CGLIB Proxy: ${proxy.javaClass.name.contains("$$")}")
```

### 2. 메서드 호출 횟수 추적
```kotlin
val handler = LoggingInvocationHandler(userService)
val proxy = createProxy(userService, handler)

proxy.findUser(1L)
proxy.findUser(2L)

println("Total method calls: ${handler.getCallCount()}") // 2
```

### 3. 실행 시간 측정
```kotlin
val interceptor = LoggingMethodInterceptor(orderService)
val proxy = createCglibProxy(orderService, interceptor)

val startTime = System.currentTimeMillis()
proxy.createOrder(1L, 5)
val endTime = System.currentTimeMillis()

println("Proxy overhead: ${endTime - startTime}ms")
```

---

## 💡 학습 팁

### 디버깅으로 확인해볼 것들
1. **프록시 객체의 실제 클래스명** - 런타임에 생성된 클래스 확인
2. **메서드 호출 스택** - 프록시 → 핸들러/인터셉터 → 타겟 흐름
3. **메모리 사용량** - 프록시 생성 전후 메모리 비교
4. **리플렉션 호출** - method.invoke() vs proxy.invokeSuper() 차이

### 성능 테스트 예시
```kotlin
@Test
fun `프록시 방식별 성능 비교`() {
    val iterations = 100_000
    
    // JDK 프록시 성능 측정
    val jdkStartTime = System.nanoTime()
    repeat(iterations) { jdkProxy.findUser(1L) }
    val jdkEndTime = System.nanoTime()
    
    // CGLIB 프록시 성능 측정  
    val cglibStartTime = System.nanoTime()
    repeat(iterations) { cglibProxy.createOrder(1L, 1) }
    val cglibEndTime = System.nanoTime()
    
    println("JDK Proxy: ${(jdkEndTime - jdkStartTime) / 1_000_000}ms")
    println("CGLIB Proxy: ${(cglibEndTime - cglibStartTime) / 1_000_000}ms")
}
```

---

**이 시각적 가이드를 통해 프록시 패턴의 동작 원리를 더 명확하게 이해하고, 실습 과정에서 참고하세요! 🎯**