# ğŸ¨ í”„ë¡ì‹œ íŒ¨í„´ ì‹œê°ì  ê°€ì´ë“œ

> í”„ë¡ì‹œ íŒ¨í„´ì˜ ë™ì‘ ì›ë¦¬ë¥¼ ë‹¤ì´ì–´ê·¸ë¨ê³¼ í•¨ê»˜ ì´í•´í•´ë³´ì„¸ìš”

## ğŸ“‹ ëª©ì°¨
1. [í”„ë¡ì‹œ íŒ¨í„´ ê¸°ë³¸ ê°œë…](#-í”„ë¡ì‹œ-íŒ¨í„´-ê¸°ë³¸-ê°œë…)
2. [ì •ì  í”„ë¡ì‹œ ë‹¤ì´ì–´ê·¸ë¨](#-ì •ì -í”„ë¡ì‹œ-ë‹¤ì´ì–´ê·¸ë¨)
3. [JDK ë™ì  í”„ë¡ì‹œ ë‹¤ì´ì–´ê·¸ë¨](#-jdk-ë™ì -í”„ë¡ì‹œ-ë‹¤ì´ì–´ê·¸ë¨)
4. [CGLIB í”„ë¡ì‹œ ë‹¤ì´ì–´ê·¸ë¨](#-cglib-í”„ë¡ì‹œ-ë‹¤ì´ì–´ê·¸ë¨)
5. [í”„ë¡ì‹œ ë°©ì‹ ë¹„êµí‘œ](#-í”„ë¡ì‹œ-ë°©ì‹-ë¹„êµí‘œ)
6. [ì‹¤í–‰ íë¦„ ë‹¤ì´ì–´ê·¸ë¨](#-ì‹¤í–‰-íë¦„-ë‹¤ì´ì–´ê·¸ë¨)

---

## ğŸ” í”„ë¡ì‹œ íŒ¨í„´ ê¸°ë³¸ ê°œë…

### í”„ë¡ì‹œ íŒ¨í„´ì´ë€?

```mermaid
graph LR
    A[Client] --> B[Proxy]
    B --> C[RealSubject]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
```

í”„ë¡ì‹œëŠ” **ì‹¤ì œ ê°ì²´ì— ëŒ€í•œ ì ‘ê·¼ì„ ì œì–´í•˜ëŠ” ëŒ€ë¦¬ì¸ ì—­í• **ì„ í•©ë‹ˆë‹¤.

### í”„ë¡ì‹œê°€ í•´ê²°í•˜ëŠ” ë¬¸ì œë“¤

```mermaid
graph TD
    A[íš¡ë‹¨ ê´€ì‹¬ì‚¬<br/>Cross-cutting Concerns] --> B[ë¡œê¹…]
    A --> C[ë³´ì•ˆ/ì¸ì¦]
    A --> D[íŠ¸ëœì­ì…˜]
    A --> E[ìºì‹±]
    A --> F[ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§]
    A --> G[ì˜ˆì™¸ ì²˜ë¦¬]
```

---

## ğŸ”§ ì •ì  í”„ë¡ì‹œ ë‹¤ì´ì–´ê·¸ë¨

### í´ë˜ìŠ¤ êµ¬ì¡°

```mermaid
classDiagram
    class UserService {
        <<interface>>
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class UserServiceImpl {
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class UserLogProxy {
        -userService: UserService
        -logInvocator: LogInvocator
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class LogInvocator {
        -callCount: AtomicInteger
        +executeWithLog(Function) T
        +getCallCount() int
        +resetCallCount()
    }
    
    UserService <|.. UserServiceImpl
    UserService <|.. UserLogProxy
    UserLogProxy --> UserService
    UserLogProxy --> LogInvocator
```

### ì‹¤í–‰ íë¦„

```mermaid
sequenceDiagram
    participant C as Client
    participant P as UserLogProxy
    participant L as LogInvocator
    participant T as UserServiceImpl
    
    C->>P: findUser(1L)
    P->>L: executeWithLog(() -> ...)
    L->>L: ë¡œê·¸ ì‹œì‘ + ì‹œê°„ ì¸¡ì •
    L->>T: findUser(1L)
    T-->>L: return "User-1"
    L->>L: ë¡œê·¸ ì¢…ë£Œ + ì‹œê°„ ì¸¡ì •
    L-->>P: return "User-1"
    P-->>C: return "User-1"
```

### ì •ì  í”„ë¡ì‹œì˜ íŠ¹ì§•
```
âœ… ì¥ì :
- êµ¬ì¡°ê°€ ë‹¨ìˆœí•˜ê³  ëª…í™•í•¨
- ì»´íŒŒì¼ ì‹œì ì— ëª¨ë“  êµ¬ì¡°ê°€ ê²°ì •ë¨
- ë””ë²„ê¹…ì´ ì‰¬ì›€

âŒ ë‹¨ì :
- ê° í´ë˜ìŠ¤ë§ˆë‹¤ í”„ë¡ì‹œ í´ë˜ìŠ¤ë¥¼ ì§ì ‘ ì‘ì„±í•´ì•¼ í•¨
- ì½”ë“œ ì¤‘ë³µì´ ë§ì´ ë°œìƒ
- íš¡ë‹¨ ê´€ì‹¬ì‚¬ê°€ ì—¬ëŸ¬ í´ë˜ìŠ¤ì— í©ì–´ì§
```

---

## ğŸ’« JDK ë™ì  í”„ë¡ì‹œ ë‹¤ì´ì–´ê·¸ë¨

### ëŸ°íƒ€ì„ êµ¬ì¡°

```mermaid
classDiagram
    class UserService {
        <<interface>>
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class UserServiceImpl {
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class ProxyInstance {
        <<runtime generated>>
        Generated by Proxy.newProxyInstance()
        +findUser(Long) String
        +saveUser(String) Long
        +deleteUser(Long) Boolean
    }
    
    class LoggingInvocationHandler {
        -target: Any
        +invoke(proxy, method, args) Any?
    }
    
    UserService <|.. UserServiceImpl
    UserService <|.. ProxyInstance
    ProxyInstance --> LoggingInvocationHandler
    LoggingInvocationHandler --> UserServiceImpl
```

### JDK ë™ì  í”„ë¡ì‹œ ìƒì„± ê³¼ì •

```mermaid
flowchart TD
    A[í´ë¼ì´ì–¸íŠ¸ ìš”ì²­] --> B[Proxy.newProxyInstance í˜¸ì¶œ]
    B --> C["ClassLoader íšë“<br/>ì¸í„°í˜ì´ìŠ¤ ë°°ì—´ íšë“<br/>InvocationHandler ìƒì„±"]
    C --> D[JVMì´ ëŸ°íƒ€ì„ì— í”„ë¡ì‹œ í´ë˜ìŠ¤ ìƒì„±]
    D --> E["$Proxy0 í´ë˜ìŠ¤<br/>(ë°”ì´íŠ¸ì½”ë“œë¡œ ìƒì„±)"]
    E --> F[í”„ë¡ì‹œ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜]
    
    subgraph "ìƒì„±ëœ í”„ë¡ì‹œ í´ë˜ìŠ¤ êµ¬ì¡°"
        G["class $Proxy0 implements UserService {<br/>  private InvocationHandler h;<br/>  public String findUser(Long id) {<br/>    return (String) h.invoke(this, method, args);<br/>  }<br/>}"]
    end
    
    D --> G
    
    style A fill:#e1f5fe
    style F fill:#e8f5e8
    style G fill:#fff3e0
```

### InvocationHandler ì‹¤í–‰ íë¦„

```mermaid
sequenceDiagram
    participant C as Client
    participant P as $Proxy0
    participant IH as LoggingInvocationHandler
    participant T as UserServiceImpl
    
    C->>P: findUser(1L)
    P->>IH: invoke(proxy, method, args)
    
    Note over IH: ì „ì²˜ë¦¬ ì‹œì‘
    IH->>IH: startTime = currentTimeMillis()
    IH->>IH: log.info("Method start: {}", method.name)
    
    Note over IH,T: ì‹¤ì œ ë©”ì„œë“œ í˜¸ì¶œ
    IH->>T: method.invoke(target, args)
    T-->>IH: return "User-1"
    
    Note over IH: í›„ì²˜ë¦¬
    IH->>IH: endTime = currentTimeMillis()
    IH->>IH: log.info("Execution time: {}ms", endTime - startTime)
    
    IH-->>P: return "User-1"
    P-->>C: return "User-1"
```

### JDK ë™ì  í”„ë¡ì‹œ íŠ¹ì§•
```
âœ… ì¥ì :
- JDK í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ (ë³„ë„ ì˜ì¡´ì„± ë¶ˆí•„ìš”)
- ëŸ°íƒ€ì„ì— í”„ë¡ì‹œ ìƒì„± (ìœ ì—°ì„±)
- í•˜ë‚˜ì˜ InvocationHandlerë¡œ ì—¬ëŸ¬ ì¸í„°í˜ì´ìŠ¤ ì²˜ë¦¬ ê°€ëŠ¥

âŒ ë‹¨ì :
- ì¸í„°í˜ì´ìŠ¤ê°€ ë°˜ë“œì‹œ í•„ìš”
- ë¦¬í”Œë ‰ì…˜ ì‚¬ìš©ìœ¼ë¡œ ì¸í•œ ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ
- ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ì´ë¯€ë¡œ í´ë˜ìŠ¤ ì§ì ‘ í”„ë¡ì‹œ ë¶ˆê°€ëŠ¥
```

---

## ğŸš€ CGLIB í”„ë¡ì‹œ ë‹¤ì´ì–´ê·¸ë¨

### ìƒì† ê¸°ë°˜ êµ¬ì¡°

```mermaid
classDiagram
    class OrderService {
        <<ì›ë³¸ í´ë˜ìŠ¤>>
        +createOrder(Long, int) String
        +cancelOrder(String) Boolean
    }
    
    class OrderServiceEnhancerByCGLIB {
        <<CGLIB ìƒì„± í”„ë¡ì‹œ>>
        -methodInterceptor: MethodInterceptor
        +createOrder(Long, int) String
        +cancelOrder(String) Boolean
    }
    
    class LoggingMethodInterceptor {
        -target: Any
        +intercept(obj, method, args, proxy) Any?
    }
    
    OrderService <|-- OrderServiceEnhancerByCGLIB
    OrderServiceEnhancerByCGLIB --> LoggingMethodInterceptor
    LoggingMethodInterceptor --> OrderService
```

### CGLIB í”„ë¡ì‹œ ìƒì„± ê³¼ì •

```mermaid
flowchart TD
    A[í´ë¼ì´ì–¸íŠ¸ ìš”ì²­] --> B[Enhancer ì¸ìŠ¤í„´ìŠ¤ ìƒì„±]
    B --> C["setSuperclass()<br/>ëŒ€ìƒ í´ë˜ìŠ¤ ì§€ì •"]
    C --> D["setCallback()<br/>MethodInterceptor ì„¤ì •"]
    D --> E[ë°”ì´íŠ¸ì½”ë“œ ì¡°ì‘ìœ¼ë¡œ ì„œë¸Œí´ë˜ìŠ¤ ìƒì„±]
    E --> F["OrderService$$EnhancerByCGLIB<br/>í´ë˜ìŠ¤ ìƒì„±"]
    F --> G[í”„ë¡ì‹œ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜]
    
    subgraph "ìƒì„±ëœ CGLIB í”„ë¡ì‹œ êµ¬ì¡°"
        H["class OrderService$$EnhancerByCGLIB<br/>    extends OrderService {<br/>  private MethodInterceptor callback;<br/>  <br/>  public String createOrder(Long id, int qty) {<br/>    return callback.intercept(this, method, args, proxy);<br/>  }<br/>}"]
    end
    
    E --> H
    
    style A fill:#e1f5fe
    style G fill:#e8f5e8
    style H fill:#fff3e0
```

### MethodInterceptor ì‹¤í–‰ íë¦„

```mermaid
sequenceDiagram
    participant C as Client
    participant P as CGLIB Proxy
    participant MI as LoggingMethodInterceptor
    participant S as OrderService(Super)
    
    C->>P: createOrder(1L, 2)
    P->>MI: intercept(obj, method, args, proxy)
    
    Note over MI: ì „ì²˜ë¦¬ ì‹œì‘
    MI->>MI: log.info("Method call: {}", method.name)
    MI->>MI: startTime = currentTimeMillis()
    
    Note over MI,S: ìƒìœ„ í´ë˜ìŠ¤ ë©”ì„œë“œ í˜¸ì¶œ
    MI->>S: proxy.invokeSuper(obj, args)
    S-->>MI: return "Order created: product=1, qty=2"
    
    Note over MI: í›„ì²˜ë¦¬
    MI->>MI: endTime = currentTimeMillis()
    MI->>MI: log.info("Execution time: {}ms", endTime - startTime)
    
    MI-->>P: return result
    P-->>C: return result
```

### CGLIB í”„ë¡ì‹œ íŠ¹ì§•
```
âœ… ì¥ì :
- ì¸í„°í˜ì´ìŠ¤ ì—†ì´ë„ í”„ë¡ì‹œ ìƒì„± ê°€ëŠ¥
- í´ë˜ìŠ¤ ê¸°ë°˜ í”„ë¡ì‹œ (ë” ìœ ì—°í•¨)
- Springì—ì„œ ê¸°ë³¸ì ìœ¼ë¡œ ì‚¬ìš©

âŒ ë‹¨ì :
- ë³„ë„ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì˜ì¡´ì„± í•„ìš”
- final í´ë˜ìŠ¤/ë©”ì„œë“œëŠ” í”„ë¡ì‹œ ë¶ˆê°€ëŠ¥
- ë°”ì´íŠ¸ì½”ë“œ ì¡°ì‘ìœ¼ë¡œ ì¸í•œ ë³µì¡ì„±
- ê¸°ë³¸ ìƒì„±ìê°€ í•„ìš”í•¨
```

---

## ğŸ“Š í”„ë¡ì‹œ ë°©ì‹ ë¹„êµí‘œ

| íŠ¹ì„± | ì •ì  í”„ë¡ì‹œ | JDK ë™ì  í”„ë¡ì‹œ | CGLIB í”„ë¡ì‹œ |
|------|-------------|----------------|-------------|
| **ìƒì„± ì‹œì ** | ì»´íŒŒì¼ ì‹œì  | ëŸ°íƒ€ì„ | ëŸ°íƒ€ì„ |
| **ì¸í„°í˜ì´ìŠ¤ í•„ìš”** | âœ… | âœ… | âŒ |
| **ë³„ë„ ì˜ì¡´ì„±** | âŒ | âŒ | âœ… |
| **ì„±ëŠ¥** | ê°€ì¥ ë¹ ë¦„ | ì¤‘ê°„ | ëŠë¦¼ |
| **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰** | ì ìŒ | ì¤‘ê°„ | ë§ìŒ |
| **final í´ë˜ìŠ¤** | ê°€ëŠ¥ | ë¶ˆê°€ëŠ¥ | ë¶ˆê°€ëŠ¥ |
| **final ë©”ì„œë“œ** | ê°€ëŠ¥ | ê°€ëŠ¥ | ë¶ˆê°€ëŠ¥ |
| **ë””ë²„ê¹… ë‚œì´ë„** | ì‰¬ì›€ | ë³´í†µ | ì–´ë ¤ì›€ |
| **ì½”ë“œ ìœ ì§€ë³´ìˆ˜** | ì–´ë ¤ì›€ | ì‰¬ì›€ | ì‰¬ì›€ |

---

## ğŸ”„ ì‹¤í–‰ íë¦„ ë‹¤ì´ì–´ê·¸ë¨

### JDK vs CGLIB ì‹¤í–‰ íë¦„ ë¹„êµ

```mermaid
sequenceDiagram
    participant C as Client
    participant P1 as JDK Proxy
    participant IH as InvocationHandler
    participant T1 as Target(Interface)
    
    participant P2 as CGLIB Proxy
    participant MI as MethodInterceptor
    participant T2 as Target(Class)

    Note over C,T2: JDK ë™ì  í”„ë¡ì‹œ íë¦„
    C->>P1: method()
    P1->>IH: invoke(proxy, method, args)
    IH->>IH: ì „ì²˜ë¦¬ (ë¡œê¹…, ì‹œê°„ ì¸¡ì •)
    IH->>T1: method.invoke(target, args)
    T1-->>IH: return result
    IH->>IH: í›„ì²˜ë¦¬ (ë¡œê¹…, ì‹œê°„ ì¸¡ì •)
    IH-->>P1: return result
    P1-->>C: return result

    Note over C,T2: CGLIB í”„ë¡ì‹œ íë¦„
    C->>P2: method()
    P2->>MI: intercept(obj, method, args, proxy)
    MI->>MI: ì „ì²˜ë¦¬ (ë¡œê¹…, ì‹œê°„ ì¸¡ì •)
    MI->>T2: proxy.invokeSuper(obj, args)
    T2-->>MI: return result
    MI->>MI: í›„ì²˜ë¦¬ (ë¡œê¹…, ì‹œê°„ ì¸¡ì •)
    MI-->>P2: return result
    P2-->>C: return result
```

---

## ğŸ¯ Springì—ì„œì˜ í”„ë¡ì‹œ ì„ íƒ ì „ëµ

### Spring AOP í”„ë¡ì‹œ ì„ íƒ íë¦„ë„

```mermaid
flowchart TD
    A[Target Bean ë¶„ì„] --> B{ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„?}
    
    B -->|Yes| C[JDK ë™ì  í”„ë¡ì‹œ]
    B -->|No| D[CGLIB í”„ë¡ì‹œ]
    
    B -->|proxy-target-class=true| D
    
    C --> E["âœ… JDK í‘œì¤€ ë°©ì‹<br/>âœ… ì„±ëŠ¥ ìš°ìˆ˜<br/>âœ… ë©”ëª¨ë¦¬ íš¨ìœ¨<br/>âŒ ì¸í„°í˜ì´ìŠ¤ í•„ìˆ˜"]
    
    D --> F["âœ… Spring ê¸°ë³¸ ë°©ì‹<br/>âœ… ì¸í„°í˜ì´ìŠ¤ ë¶ˆí•„ìš”<br/>âœ… ìœ ì—°ì„± ë†’ìŒ<br/>âŒ final ì œì•½ì‚¬í•­"]
    
    subgraph "ì„¤ì •ìœ¼ë¡œ ê°•ì œ ì„ íƒ ê°€ëŠ¥"
        G["@EnableAspectJAutoProxy<br/>(proxyTargetClass = true)"]
        H["spring.aop.proxy-target-class=true"]
    end
    
    G -.-> D
    H -.-> D
    
    style A fill:#e1f5fe
    style C fill:#e8f5e8
    style D fill:#fff3e0
    style E fill:#f0f8ff
    style F fill:#f5f5dc
```

### ì„¤ì •ì„ í†µí•œ í”„ë¡ì‹œ ê°•ì œ ì„ íƒ
```kotlin
// application.yml
spring:
  aop:
    proxy-target-class: true  # CGLIB ê°•ì œ ì‚¬ìš©

// ë˜ëŠ” ì–´ë…¸í…Œì´ì…˜
@EnableAspectJAutoProxy(proxyTargetClass = true)
```

---

## ğŸ§ª ì‹¤ìŠµì—ì„œ í™•ì¸í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤

### 1. í”„ë¡ì‹œ ê°ì²´ íƒ€ì… í™•ì¸
```kotlin
val proxy = createProxy(userService)
println("Proxy class: ${proxy.javaClass.name}")
println("Is JDK Proxy: ${Proxy.isProxyClass(proxy.javaClass)}")
println("Is CGLIB Proxy: ${proxy.javaClass.name.contains("$$")}")
```

### 2. ë©”ì„œë“œ í˜¸ì¶œ íšŸìˆ˜ ì¶”ì 
```kotlin
val handler = LoggingInvocationHandler(userService)
val proxy = createProxy(userService, handler)

proxy.findUser(1L)
proxy.findUser(2L)

println("Total method calls: ${handler.getCallCount()}") // 2
```

### 3. ì‹¤í–‰ ì‹œê°„ ì¸¡ì •
```kotlin
val interceptor = LoggingMethodInterceptor(orderService)
val proxy = createCglibProxy(orderService, interceptor)

val startTime = System.currentTimeMillis()
proxy.createOrder(1L, 5)
val endTime = System.currentTimeMillis()

println("Proxy overhead: ${endTime - startTime}ms")
```

---

## ğŸ’¡ í•™ìŠµ íŒ

### ë””ë²„ê¹…ìœ¼ë¡œ í™•ì¸í•´ë³¼ ê²ƒë“¤
1. **í”„ë¡ì‹œ ê°ì²´ì˜ ì‹¤ì œ í´ë˜ìŠ¤ëª…** - ëŸ°íƒ€ì„ì— ìƒì„±ëœ í´ë˜ìŠ¤ í™•ì¸
2. **ë©”ì„œë“œ í˜¸ì¶œ ìŠ¤íƒ** - í”„ë¡ì‹œ â†’ í•¸ë“¤ëŸ¬/ì¸í„°ì…‰í„° â†’ íƒ€ê²Ÿ íë¦„
3. **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰** - í”„ë¡ì‹œ ìƒì„± ì „í›„ ë©”ëª¨ë¦¬ ë¹„êµ
4. **ë¦¬í”Œë ‰ì…˜ í˜¸ì¶œ** - method.invoke() vs proxy.invokeSuper() ì°¨ì´

### ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ
```kotlin
@Test
fun `í”„ë¡ì‹œ ë°©ì‹ë³„ ì„±ëŠ¥ ë¹„êµ`() {
    val iterations = 100_000
    
    // JDK í”„ë¡ì‹œ ì„±ëŠ¥ ì¸¡ì •
    val jdkStartTime = System.nanoTime()
    repeat(iterations) { jdkProxy.findUser(1L) }
    val jdkEndTime = System.nanoTime()
    
    // CGLIB í”„ë¡ì‹œ ì„±ëŠ¥ ì¸¡ì •  
    val cglibStartTime = System.nanoTime()
    repeat(iterations) { cglibProxy.createOrder(1L, 1) }
    val cglibEndTime = System.nanoTime()
    
    println("JDK Proxy: ${(jdkEndTime - jdkStartTime) / 1_000_000}ms")
    println("CGLIB Proxy: ${(cglibEndTime - cglibStartTime) / 1_000_000}ms")
}
```

---

**ì´ ì‹œê°ì  ê°€ì´ë“œë¥¼ í†µí•´ í”„ë¡ì‹œ íŒ¨í„´ì˜ ë™ì‘ ì›ë¦¬ë¥¼ ë” ëª…í™•í•˜ê²Œ ì´í•´í•˜ê³ , ì‹¤ìŠµ ê³¼ì •ì—ì„œ ì°¸ê³ í•˜ì„¸ìš”! ğŸ¯**